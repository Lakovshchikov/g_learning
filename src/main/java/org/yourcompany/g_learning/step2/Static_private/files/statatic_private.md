# 📅 Инкапсуляция, статика и final

🎯 **Цель:** научиться скрывать данные, работать со статическими членами класса и создавать константы.

---

## 🧭 Что изучим в этой лекции

- **Инкапсуляция** — сокрытие данных и контроль доступа
- **Статические поля** — данные, общие для всех объектов класса
- **Статические методы** — методы, которые не требуют создания объекта
- **final** — создание констант и неизменяемых значений

---

## 📚 Теория

### 🔒 1. Инкапсуляция и модификатор `private`

#### Что такое инкапсуляция простыми словами?

Представь, что у тебя есть **банковская карта**. Ты можешь:

- ✅ Снять деньги через банкомат
- ✅ Проверить баланс
- ✅ Пополнить счёт

Но ты **НЕ МОЖЕШЬ**:

- ❌ Открыть карту и напрямую изменить баланс
- ❌ Напрямую добавить себе миллион
- ❌ Удалить информацию о транзакциях

Банк **скрыл** внутреннюю реализацию и дал тебе только **безопасные методы** для работы со счётом. Это и есть **инкапсуляция** — сокрытие внутренних данных и предоставление контролируемого доступа.

#### Инкапсуляция в программировании

**Инкапсуляция** — это принцип ООП, который означает:

1. **Скрываем** внутренние данные объекта (делаем поля `private`)
2. **Предоставляем** публичные методы для работы с этими данными (геттеры и сеттеры)
3. **Контролируем** все изменения данных (добавляем проверки)

#### Зачем нужна инкапсуляция?

- ✅ **Защита данных** — нельзя установить некорректные значения (отрицательный возраст, пустое имя)
- ✅ **Контроль** — мы видим и контролируем все изменения
- ✅ **Гибкость** — можем изменить внутреннюю реализацию без изменения внешнего кода
- ✅ **Безопасность** — важные данные защищены от случайного изменения

#### Пример БЕЗ инкапсуляции (ПЛОХО)

```java
class BankAccount {
    String accountNumber;
    double balance;  // Баланс доступен всем!
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.accountNumber = "123456";
        account.balance = 1000.0;

        // ОПАСНО! Любой может изменить баланс напрямую:
        account.balance = 1000000.0;  // Добавил себе миллион!
        account.balance = -500.0;     // Баланс стал отрицательным!

        System.out.println("Баланс: " + account.balance);
    }
}
```

**Проблемы:**

- ❌ Можно установить любое значение баланса
- ❌ Нет проверок на корректность
- ❌ Невозможно отследить, кто и когда изменил данные
- ❌ Можно случайно испортить данные

#### Пример С инкапсуляцией (ХОРОШО)

```java
class BankAccount {
    private String accountNumber;  // Скрыли данные
    private double balance;        // Скрыли данные

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    // Геттер — безопасное чтение
    public double getBalance() {
        return balance;
    }

    // Контролируемое пополнение
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Пополнено на: " + amount);
        } else {
            System.out.println("Сумма должна быть положительной!");
        }
    }

    // Контролируемое снятие
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Снято: " + amount);
            return true;
        } else {
            System.out.println("Недостаточно средств или некорректная сумма!");
            return false;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("123456", 1000.0);

        // account.balance = 1000000.0;  // ОШИБКА КОМПИЛЯЦИИ! Поле private!

        account.deposit(500);      // OK: баланс = 1500
        account.withdraw(300);     // OK: баланс = 1200
        account.withdraw(2000);    // Ошибка: недостаточно средств
        account.deposit(-100);     // Ошибка: отрицательная сумма

        System.out.println("Баланс: " + account.getBalance());
    }
}
```

**Преимущества:**

- ✅ Невозможно напрямую изменить баланс
- ✅ Все операции проверяются
- ✅ Защита от некорректных данных
- ✅ Понятный и безопасный API

#### Геттеры и сеттеры — что это?

**Геттер** (getter) — метод для **чтения** значения приватного поля  
**Сеттер** (setter) — метод для **изменения** значения приватного поля

```java
class User {
    private String name;  // Приватное поле
    private int age;

    // Геттер для name
    public String getName() {
        return name;  // Просто возвращаем значение
    }

    // Сеттер для name
    public void setName(String name) {
        if (name != null && !name.isEmpty()) {  // Проверка
            this.name = name;
        } else {
            System.out.println("Имя не может быть пустым!");
        }
    }

    // Геттер для age
    public int getAge() {
        return age;
    }

    // Сеттер для age с проверкой
    public void setAge(int age) {
        if (age > 0 && age < 150) {
            this.age = age;
        } else {
            System.out.println("Некорректный возраст!");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        User user = new User();

        user.setName("Алексей");  // Устанавливаем через сеттер
        user.setAge(25);

        System.out.println("Имя: " + user.getName());    // Читаем через геттер
        System.out.println("Возраст: " + user.getAge());

        user.setAge(-5);      // Ошибка валидации
        user.setName("");     // Ошибка валидации
    }
}
```

#### Правила инкапсуляции

1. **Всегда** делай поля класса `private`
2. **Создавай** геттеры для чтения данных
3. **Создавай** сеттеры для изменения данных (если нужно)
4. **Добавляй** проверки в сеттеры
5. **Не создавай** сеттеры для полей, которые не должны меняться

**Правило:** Всегда делайте поля `private` и предоставляйте доступ через геттеры и сеттеры!

---

### ⚡ 2. Статические поля (`static`)

**Статические члены** принадлежат **классу**, а не конкретному объекту.

#### Ключевые отличия

- **Экземплярные** (instance) — у каждого объекта своя копия
- **Статические** (static) — общая для всех объектов класса

Статические поля используются когда нужно:

- Хранить данные, общие для всех объектов
- Считать количество созданных объектов
- Хранить настройки или конфигурацию

#### Пример со счётчиком объектов

```java
class Student {
    private static int studentCount = 0;  // Статическое поле (общее для всех)
    private int id;                        // Экземплярное поле (у каждого своё)
    private String name;

    public Student(String name) {
        studentCount++;           // Увеличиваем общий счётчик
        this.id = studentCount;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    // Статический метод — можно вызывать без создания объекта
    public static int getStudentCount() {
        return studentCount;
    }

    public void printInfo() {
        System.out.println("Студент #" + id + ": " + name +
                         " (всего создано: " + studentCount + ")");
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println("Создано студентов: " + Student.getStudentCount());  // 0

        Student s1 = new Student("Иван");
        Student s2 = new Student("Мария");
        Student s3 = new Student("Алексей");

        s1.printInfo();  // Студент #1: Иван (всего создано: 3)
        s2.printInfo();  // Студент #2: Мария (всего создано: 3)
        s3.printInfo();  // Студент #3: Алексей (всего создано: 3)

        System.out.println("Создано студентов: " + Student.getStudentCount());  // 3
    }
}
```

---

### 🔧 3. Статические методы (`static`)

**Статические методы** можно вызывать **без создания объекта класса**.

#### Важные правила

- ❌ Статический метод **НЕ может** обращаться к экземплярным полям/методам
- ✅ Статический метод **может** обращаться к другим статическим членам
- ✅ Экземплярный метод **может** обращаться к статическим членам

#### Пример

```java
class Calculator {
    private static final double PI = 3.14159;

    // Статические методы — не требуют создания объекта
    public static int sum(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }

    public static double circleArea(double radius) {
        return PI * radius * radius;
    }

    public static double power(double base, int exponent) {
        double result = 1;
        for (int i = 0; i < exponent; i++) {
            result *= base;
        }
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        // Вызываем статические методы БЕЗ создания объекта
        System.out.println("10 + 5 = " + Calculator.sum(10, 5));
        System.out.println("10 * 5 = " + Calculator.multiply(10, 5));
        System.out.println("Площадь круга (r=5): " + Calculator.circleArea(5));
        System.out.println("2^8 = " + Calculator.power(2, 8));
    }
}
```

#### Когда использовать статические методы?

- ✅ Утилитарные функции (математика, конвертация)
- ✅ Фабричные методы для создания объектов
- ✅ Методы, которые не зависят от состояния объекта

---

### 🔐 4. Константы (`final`)

**Константа** — это значение, которое **не может быть изменено** после инициализации.

#### Ключевые слова

- **`final`** — значение нельзя изменить
- **`static final`** — константа класса (общая для всех)

#### Naming convention

Константы пишутся **ЗАГЛАВНЫМИ*БУКВАМИ*С_ПОДЧЁРКИВАНИЕМ**

#### Пример

```java
class AppConfig {
    // Константы класса
    public static final String APP_NAME = "MyApp";
    public static final String VERSION = "1.0.0";
    public static final int MAX_USERS = 1000;
    public static final int MIN_AGE = 18;
    public static final int MAX_AGE = 100;
    public static final double TAX_RATE = 0.13;

    // Статический метод с использованием констант
    public static double calculateTax(double amount) {
        return amount * TAX_RATE;
    }

    public static void printInfo() {
        System.out.println("Приложение: " + APP_NAME);
        System.out.println("Версия: " + VERSION);
        System.out.println("Максимум пользователей: " + MAX_USERS);
    }
}

public class Main {
    public static void main(String[] args) {
        AppConfig.printInfo();

        double salary = 50000;
        System.out.println("Налог с зарплаты: " + AppConfig.calculateTax(salary));

        // AppConfig.MAX_USERS = 2000;  // ОШИБКА! Нельзя изменить final
    }
}
```

#### Использование `final` для переменных

```java
class Example {
    private final int id;  // final поле — устанавливается только в конструкторе

    public Example(int id) {
        this.id = id;
        // this.id = 10;  // ОШИБКА! Уже установлено
    }

    public void process() {
        final int LOCAL_LIMIT = 100;  // Локальная константа
        System.out.println("Лимит: " + LOCAL_LIMIT);
        // LOCAL_LIMIT = 200;  // ОШИБКА! Нельзя изменить
    }
}
```

---

## 💪 Практические задачи

### Задача 1: Класс "Банковский счёт"

Создай класс `BankAccount` с инкапсуляцией:

**Требования:**

- Приватные поля: `accountNumber` (String), `balance` (double), `ownerName` (String)
- Константа: `MIN_BALANCE` = 100.0
- Конструктор, который инициализирует счёт с начальным балансом
- Геттеры для всех полей
- Методы:
  - `deposit(double amount)` — пополнение счёта (только положительные суммы)
  - `withdraw(double amount)` — снятие денег (проверка минимального баланса)
  - `printInfo()` — вывод информации о счёте

**Пример использования:**

```java
BankAccount account = new BankAccount("123456", "Иван Петров", 5000);
account.deposit(2000);
account.withdraw(3000);
account.printInfo();  // Баланс: 4000
account.withdraw(4000);  // Ошибка: минимальный баланс 100
```

---

### Задача 2: Класс "Библиотека книг" (работа с массивом объектов)

Создай класс `Book` для управления библиотекой книг.

#### Требования к классу

**Поля:**

- `title` (String, private) — название книги
- `author` (String, private) — автор
- `year` (int, private) — год издания
- `isAvailable` (boolean, private) — доступна ли книга (true = в библиотеке, false = на руках)
- `totalBooks` (static int, private) — общее количество книг в системе

**Константы:**

- `MIN_YEAR` = 1000 — минимальный год издания
- `MAX_YEAR` = 2025 — максимальный год издания

**Конструктор:**

- Принимает: название, автор, год
- Проверяет год (должен быть между MIN_YEAR и MAX_YEAR)
- Увеличивает счётчик totalBooks
- Устанавливает isAvailable = true (книга изначально доступна)

**Методы:**

1. **Геттеры** для всех полей: `getTitle()`, `getAuthor()`, `getYear()`, `isAvailable()`
2. **`borrowBook()`** — взять книгу:
   - Если книга доступна → делает isAvailable = false, выводит "Книга '<название>' взята"
   - Если недоступна → выводит "Книга '<название>' уже на руках"
3. **`returnBook()`** — вернуть книгу:
   - Если книга на руках → делает isAvailable = true, выводит "Книга '<название>' возвращена"
   - Если уже в библиотеке → выводит "Книга '<название>' уже в библиотеке"
4. **`printInfo()`** — вывод информации:
   - Формат: "«Название» - Автор (Год) [Доступна/На руках]"
5. **`static int getTotalBooks()`** — вернуть общее количество книг

#### Задание

1. Создай массив из 5 книг (выбери любые книги)
2. Выведи информацию о всех книгах
3. Выведи только доступные книги (используй цикл и проверку)
4. Возьми 2 любые книги (вызови `borrowBook()`)
5. Попробуй взять одну из уже взятых книг (увидишь сообщение об ошибке)
6. Верни 1 книгу
7. Снова выведи все доступные книги
8. Выведи общее количество книг в системе

#### Пример использования

```java
public class Main {
    public static void main(String[] args) {
        // 1. Создание библиотеки
        Book[] library = {
            new Book("1984", "George Orwell", 1949),
            new Book("Война и мир", "Лев Толстой", 1869),
            new Book("Мастер и Маргарита", "Михаил Булгаков", 1967),
            new Book("Преступление и наказание", "Федор Достоевский", 1866),
            new Book("Гарри Поттер", "Джоан Роулинг", 1997)
        };

        System.out.println("=== Все книги в библиотеке ===");


        System.out.println("\n=== Доступные книги ===");


        // 4. Взять 2 книги
        System.out.println("\n=== Берём книги ===");


        // 5. Попытка взять уже взятую книгу


        // 6. Возврат книги
        System.out.println("\n=== Возвращаем книгу ===");

        // 7. Снова выводим доступные
        System.out.println("\n=== Доступные книги после операций ===");

        // 8. Общее количество
    }
}
```

#### Ожидаемый результат

```
=== Все книги в библиотеке ===
«1984» - George Orwell (1949) [Доступна]
«Война и мир» - Лев Толстой (1869) [Доступна]
«Мастер и Маргарита» - Михаил Булгаков (1967) [Доступна]
«Преступление и наказание» - Федор Достоевский (1866) [Доступна]
«Гарри Поттер» - Джоан Роулинг (1997) [Доступна]

=== Доступные книги ===
«1984» - George Orwell (1949) [Доступна]
«Война и мир» - Лев Толстой (1869) [Доступна]
«Мастер и Маргарита» - Михаил Булгаков (1967) [Доступна]
«Преступление и наказание» - Федор Достоевский (1866) [Доступна]
«Гарри Поттер» - Джоан Роулинг (1997) [Доступна]

=== Берём книги ===
Книга '1984' взята
Книга 'Мастер и Маргарита' взята
Книга '1984' уже на руках

=== Возвращаем книгу ===
Книга '1984' возвращена

=== Доступные книги после операций ===
«1984» - George Orwell (1949) [Доступна]
«Война и мир» - Лев Толстой (1869) [Доступна]
«Преступление и наказание» - Федор Достоевский (1866) [Доступна]
«Гарри Поттер» - Джоан Роулинг (1997) [Доступна]

Всего книг в системе: 5
```

---

### Задача 3: Класс "Магазин" (работа с массивом объектов + вычисления)

Создай класс `Product` для управления товарами в магазине.

#### Требования к классу

**Поля:**

- `id` (int, private, final) — уникальный ID товара (генерируется автоматически)
- `name` (String, private) — название товара
- `price` (double, private) — цена за единицу
- `quantity` (int, private) — количество на складе
- `productCount` (static int, private) — счётчик всех товаров

**Константы:**

- `MAX_PRICE` = 1_000_000.0 — максимальная цена товара
- `MIN_PRICE` = 0.01 — минимальная цена товара

**Конструктор:**

- Принимает: название, цена, количество
- Увеличивает productCount и присваивает значение в id
- Проверяет цену (между MIN_PRICE и MAX_PRICE)
- Проверяет количество (>= 0)

**Методы:**

1. **Геттеры:** `getId()`, `getName()`, `getPrice()`, `getQuantity()`
2. **Сеттеры с валидацией:**
   - `setPrice(double price)` — проверка диапазона
   - `setQuantity(int quantity)` — проверка >= 0
3. **`getTotalPrice()`** — вернуть общую стоимость товара на складе (цена × количество)
4. **`sell(int amount)`** — продать товар:
   - Проверить, что amount > 0 и amount <= quantity
   - Уменьшить quantity на amount
   - Вывести: "Продано <amount> шт. товара '<название>'"
   - Если недостаточно → вывести ошибку
5. **`addStock(int amount)`** — добавить товар на склад:
   - Проверить amount > 0
   - Увеличить quantity
6. **`printInfo()`** — вывод информации:
   - Формат: "ID: <id>, Товар: <название>, Цена: <цена>, Кол-во: <кол-во>, Итого: <общая стоимость>"
7. **`static int getProductCount()`** — вернуть количество товаров

#### Задание

1. Создай массив из 5 товаров (например: ноутбук, мышь, клавиатура, монитор, наушники)
2. Выведи информацию о всех товарах
3. Найди и выведи самый дорогой товар (по цене за единицу)
4. Найди и выведи самый дешёвый товар
5. Продай 3 единицы самого дешёвого товара
6. Попробуй продать больше, чем есть на складе (увидишь ошибку)
7. Посчитай общую стоимость всех товаров на складе
8. Выведи товары, которых осталось меньше 10 штук

#### Пример использования

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("=== Магазин электроники ===\n");

        // 1. Создание товаров
        Product[] products = {
            new Product("Ноутбук", 50000, 15),
            new Product("Мышь", 500, 50),
            new Product("Клавиатура", 1500, 30),
            new Product("Монитор", 20000, 8),
            new Product("Наушники", 3000, 25)
        };

        // 2. Вывод всех товаров
        System.out.println("Все товары:");


        // 3. Поиск самого дорогого
        System.out.println("\n=== Поиск самого дорогого товара ===");

        System.out.println("Самый дорогой товар:");

        // 4. Поиск самого дешёвого
        System.out.println("\n=== Поиск самого дешёвого товара ===");

        System.out.println("Самый дешёвый товар:");

        // 5. Продажа дешёвого товара
        System.out.println("\n=== Продажа ===");


        // 6. Попытка продать больше чем есть


        // 7. Общая стоимость склада
        System.out.println("\n=== Общая стоимость склада ===");


        // 8. Товары с низким остатком
        System.out.println("\n=== Товары с низким остатком (< 10 шт.) ===");


        System.out.println("\nВсего товаров в системе: " + Product.getProductCount());
    }
}
```

#### Ожидаемый результат

```
=== Магазин электроники ===

Все товары:
ID: 1, Товар: Ноутбук, Цена: 50000.0, Кол-во: 15, Итого: 750000.0
ID: 2, Товар: Мышь, Цена: 500.0, Кол-во: 50, Итого: 25000.0
ID: 3, Товар: Клавиатура, Цена: 1500.0, Кол-во: 30, Итого: 45000.0
ID: 4, Товар: Монитор, Цена: 20000.0, Кол-во: 8, Итого: 160000.0
ID: 5, Товар: Наушники, Цена: 3000.0, Кол-во: 25, Итого: 75000.0

=== Поиск самого дорогого товара ===
Самый дорогой товар:
ID: 1, Товар: Ноутбук, Цена: 50000.0, Кол-во: 15, Итого: 750000.0

=== Поиск самого дешёвого товара ===
Самый дешёвый товар:
ID: 2, Товар: Мышь, Цена: 500.0, Кол-во: 50, Итого: 25000.0

=== Продажа ===
Продано 3 шт. товара 'Мышь'
ID: 2, Товар: Мышь, Цена: 500.0, Кол-во: 47, Итого: 23500.0
Недостаточно товара на складе!

=== Общая стоимость склада ===
Общая стоимость всех товаров: 1053500.0 руб.

=== Товары с низким остатком (< 10 шт.) ===
ID: 4, Товар: Монитор, Цена: 20000.0, Кол-во: 8, Итого: 160000.0

Всего товаров в системе: 5
```

---

### Задача 4: Класс "Счётчик посещений сайта"

Создай класс `WebsiteVisitor` для учёта посетителей веб-сайта.

#### Требования к классу

**Статические поля:**

- `totalVisitors` (private) — общее количество всех посетителей
- `activeVisitors` (private) — количество активных посетителей сейчас

**Константы:**

- `MAX_ACTIVE_VISITORS` = 100 — максимальное количество одновременных посетителей

**Поля экземпляра:**

- `visitorId` (private, final) — уникальный ID посетителя
- `name` (private) — имя посетителя
- `isOnline` (private) — находится ли посетитель на сайте

**Конструктор:**

- Принимает имя посетителя
- Увеличивает totalVisitors
- Присваивает уникальный ID
- Устанавливает isOnline = false

**Методы:**

1. **`login()`** — посетитель заходит на сайт:
   - Проверить, что activeVisitors < MAX_ACTIVE_VISITORS
   - Если уже онлайн → вывести "Пользователь уже на сайте"
   - Иначе: установить isOnline = true, увеличить activeVisitors
   - Вывести: "<Имя> зашёл на сайт (Онлайн: X)"
2. **`logout()`** — посетитель выходит:
   - Если не онлайн → вывести "Пользователь не был на сайте"
   - Иначе: установить isOnline = false, уменьшить activeVisitors
   - Вывести: "<Имя> вышел с сайта (Онлайн: X)"
3. **`printInfo()`** — вывод информации о посетителе
4. **Статические методы:**
   - `static int getTotalVisitors()` — общее количество посетителей
   - `static int getActiveVisitors()` — количество онлайн сейчас
   - `static void printStatistics()` — вывести статистику сайта

#### Задание

1. Создай 5 посетителей
2. Выведи начальную статистику
3. Сделай так, чтобы 3 посетителя зашли на сайт (login)
4. Выведи статистику (должно быть 3 онлайн)
5. 1 посетитель выходит (logout)
6. Попробуй войти повторно уже онлайн-посетителем
7. Попробуй выйти пользователем, который не был онлайн
8. Выведи финальную статистику

#### Пример использования

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("=== Система учёта посетителей сайта ===\n");

        // 1. Регистрация посетителей
        WebsiteVisitor[] visitors = {
            new WebsiteVisitor("Алексей"),
            new WebsiteVisitor("Мария"),
            new WebsiteVisitor("Иван"),
            new WebsiteVisitor("Ольга"),
            new WebsiteVisitor("Дмитрий")
        };

        // 2. Начальная статистика

        // 3. Посетители заходят
        System.out.println("\n=== Посетители заходят ===");


        // 4. Текущая статистика
        System.out.println();
        WebsiteVisitor.printStatistics();

        // 5. Один выходит
        System.out.println("\n=== Посетитель выходит ===");

        // 6. Попытка войти повторно
        System.out.println("\n=== Попытка повторного входа ===");

        // 7. Попытка выйти неактивным
        System.out.println("\n=== Попытка выхода неактивным пользователем ===");

        // 8. Финальная статистика
        System.out.println();
    }
}
```

**Подсказка:** Эта задача показывает, как статические поля могут использоваться для отслеживания глобального состояния всех объектов класса.

---

## 🎯 Вопросы для самопроверки

1. Что такое инкапсуляция и зачем она нужна?
2. Почему поля класса лучше делать `private`, а не `public`?
3. Для чего используются геттеры и сеттеры?
4. Можно ли в сеттере добавить проверку (валидацию) данных?
5. Что такое статическое поле? Чем оно отличается от экземплярного?
6. Как создать счётчик объектов класса с помощью статического поля?
7. Можно ли вызвать статический метод без создания объекта класса?
8. Может ли статический метод обращаться к экземплярным полям? Почему?
9. Может ли экземплярный метод обращаться к статическим полям?
10. Что означает ключевое слово `final` для переменной?
11. Как объявить константу класса в Java?
12. Как принято называть константы в Java (naming convention)?
13. Можно ли изменить значение переменной, объявленной как `final`?
14. В чём разница между `final` и `static final`?
15. Приведи пример, когда нужно использовать статический метод вместо экземплярного.

---

## 📌 Итоги

✅ **Инкапсуляция** — защита данных через `private` и контролируемый доступ  
✅ **Статические поля** — данные, общие для всех объектов класса  
✅ **Статические методы** — методы, не требующие создания объекта  
✅ **final** — создание неизменяемых значений и констант

**Помни:**

- Всегда делай поля `private`
- Используй геттеры/сеттеры для доступа к полям
- Добавляй валидацию в сеттерах
- Используй `static` для общих данных и утилитарных методов
- Константы пиши `ЗАГЛАВНЫМИ_БУКВАМИ`

---

**Успехов в изучении ООП! 🚀**
